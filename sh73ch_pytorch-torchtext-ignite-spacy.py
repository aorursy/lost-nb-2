#!/usr/bin/env python
# coding: utf-8

# In[ ]:


ignite_wheel = '''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
Z2luZXMvdGJwdHQucHlQSwECFAMUAAAACAAwm2lNhWEQsXgAAADNAAAAIwAAAAAAAAAAAAAAtIHJ
CgAAaWduaXRlL2NvbnRyaWIvaGFuZGxlcnMvX19pbml0X18ucHlQSwECFAMUAAAACAAwm2lNiyzO
KA4IAABHJQAAKgAAAAAAAAAAAAAAtIGCCwAAaWduaXRlL2NvbnRyaWIvaGFuZGxlcnMvcGFyYW1f
c2NoZWR1bGVyLnB5UEsBAhQDFAAAAAgAMJtpTUuyfcjGBQAALBEAACYAAAAAAAAAAAAAALSB2BMA
AGlnbml0ZS9jb250cmliL2hhbmRsZXJzL3RxZG1fbG9nZ2VyLnB5UEsBAhQDFAAAAAgAMJtpTe7Q
CZFpAAAAtgAAACIAAAAAAAAAAAAAALSB4hkAAGlnbml0ZS9jb250cmliL21ldHJpY3MvX19pbml0
X18ucHlQSwECFAMUAAAACAAwm2lNlJ2vHqYCAABRBgAAKwAAAAAAAAAAAAAAtIGLGgAAaWduaXRl
L2NvbnRyaWIvbWV0cmljcy9hdmVyYWdlX3ByZWNpc2lvbi5weVBLAQIUAxQAAAAIADCbaU1V4HY+
SwEAAP8CAAAdAAAAAAAAAAAAAAC0gXodAABpZ25pdGUvY29udHJpYi9tZXRyaWNzL21hZS5weVBL
AQIUAxQAAAAIADCbaU1v9zWqwwIAACMGAAAhAAAAAAAAAAAAAAC0gQAfAABpZ25pdGUvY29udHJp
Yi9tZXRyaWNzL3JvY19hdWMucHlQSwECFAMUAAAACAAwm2lNXAtnyHADAACHDAAAGQAAAAAAAAAA
AAAAtIECIgAAaWduaXRlL2VuZ2luZS9fX2luaXRfXy5weVBLAQIUAxQAAAAIADCbaU2bjALuoQwA
AO4uAAAXAAAAAAAAAAAAAAC0gaklAABpZ25pdGUvZW5naW5lL2VuZ2luZS5weVBLAQIUAxQAAAAI
ADCbaU3v8RrNbQAAANUAAAAbAAAAAAAAAAAAAAC0gX8yAABpZ25pdGUvaGFuZGxlcnMvX19pbml0
X18ucHlQSwECFAMUAAAACAAwm2lNxyr4yCIJAABKHgAAHQAAAAAAAAAAAAAAtIElMwAAaWduaXRl
L2hhbmRsZXJzL2NoZWNrcG9pbnQucHlQSwECFAMUAAAACAAwm2lN1c5F9FADAABWCQAAIQAAAAAA
AAAAAAAAtIGCPAAAaWduaXRlL2hhbmRsZXJzL2Vhcmx5X3N0b3BwaW5nLnB5UEsBAhQDFAAAAAgA
MJtpTabUo0VDAwAAyAcAACMAAAAAAAAAAAAAALSBEUAAAGlnbml0ZS9oYW5kbGVycy90ZXJtaW5h
dGVfb25fbmFuLnB5UEsBAhQDFAAAAAgAMJtpTa7Py10eBQAAPREAABkAAAAAAAAAAAAAALSBlUMA
AGlnbml0ZS9oYW5kbGVycy90aW1pbmcucHlQSwECFAMUAAAACAAwm2lN0mMDz+gAAAAcAwAAGgAA
AAAAAAAAAAAAtIHqSAAAaWduaXRlL21ldHJpY3MvX19pbml0X18ucHlQSwECFAMUAAAACAAwm2lN
OD1CWqICAADIBwAAGgAAAAAAAAAAAAAAtIEKSgAAaWduaXRlL21ldHJpY3MvYWNjdXJhY3kucHlQ
SwECFAMUAAAACAAwm2lNQ1hsSu8AAADeAQAAIQAAAAAAAAAAAAAAtIHkTAAAaWduaXRlL21ldHJp
Y3MvYmluYXJ5X2FjY3VyYWN5LnB5UEsBAhQDFAAAAAgAMJtpTRltT+zyAAAA6AEAACYAAAAAAAAA
AAAAALSBEk4AAGlnbml0ZS9tZXRyaWNzL2NhdGVnb3JpY2FsX2FjY3VyYWN5LnB5UEsBAhQDFAAA
AAgAMJtpTQZZGNNuBAAATQwAAB4AAAAAAAAAAAAAALSBSE8AAGlnbml0ZS9tZXRyaWNzL2Vwb2No
X21ldHJpYy5weVBLAQIUAxQAAAAIADCbaU1njNO4MAMAAEMIAAAWAAAAAAAAAAAAAAC0gfJTAABp
Z25pdGUvbWV0cmljcy9sb3NzLnB5UEsBAhQDFAAAAAgAMJtpTcaZnWxxAQAAXwMAACUAAAAAAAAA
AAAAALSBVlcAAGlnbml0ZS9tZXRyaWNzL21lYW5fYWJzb2x1dGVfZXJyb3IucHlQSwECFAMUAAAA
CAAwm2lNdf1ujdEBAABBBAAAKAAAAAAAAAAAAAAAtIEKWQAAaWduaXRlL21ldHJpY3MvbWVhbl9w
YWlyd2lzZV9kaXN0YW5jZS5weVBLAQIUAxQAAAAIADCbaU14niaGcwEAAFoDAAAkAAAAAAAAAAAA
AAC0gSFbAABpZ25pdGUvbWV0cmljcy9tZWFuX3NxdWFyZWRfZXJyb3IucHlQSwECFAMUAAAACAAw
m2lN6FfyffUCAAAcCAAAGAAAAAAAAAAAAAAAtIHWXAAAaWduaXRlL21ldHJpY3MvbWV0cmljLnB5
UEsBAhQDFAAAAAgAMJtpTemdfR2jAwAATAsAABsAAAAAAAAAAAAAALSBAWAAAGlnbml0ZS9tZXRy
aWNzL3ByZWNpc2lvbi5weVBLAQIUAxQAAAAIADCbaU2rjnsRpAMAAPMKAAAYAAAAAAAAAAAAAAC0
gd1jAABpZ25pdGUvbWV0cmljcy9yZWNhbGwucHlQSwECFAMUAAAACAAwm2lNFeu4DNsAAACEAQAA
KQAAAAAAAAAAAAAAtIG3ZwAAaWduaXRlL21ldHJpY3Mvcm9vdF9tZWFuX3NxdWFyZWRfZXJyb3Iu
cHlQSwECFAMUAAAACAAwm2lNTHcQbzoEAACFDQAAIQAAAAAAAAAAAAAAtIHZaAAAaWduaXRlL21l
dHJpY3MvcnVubmluZ19hdmVyYWdlLnB5UEsBAhQDFAAAAAgAMJtpTdbXWQLlAQAAZAQAACwAAAAA
AAAAAAAAALSBUm0AAGlnbml0ZS9tZXRyaWNzL3RvcF9rX2NhdGVnb3JpY2FsX2FjY3VyYWN5LnB5
UEsBAhQDFAAAAAgAbp1pTcbFdoIXAwAA6AUAACYAAAAAAAAAAAAAALSBgW8AAHB5dG9yY2hfaWdu
aXRlLTAuMS4xLmRpc3QtaW5mby9MSUNFTlNFUEsBAhQDFAAAAAgAbp1pTe2LmXwIBgAAyg0AACcA
AAAAAAAAAAAAALSB3HIAAHB5dG9yY2hfaWduaXRlLTAuMS4xLmRpc3QtaW5mby9NRVRBREFUQVBL
AQIUAxQAAAAIAG6daU08Ro/MXwAAAG4AAAAkAAAAAAAAAAAAAAC0gSl5AABweXRvcmNoX2lnbml0
ZS0wLjEuMS5kaXN0LWluZm8vV0hFRUxQSwECFAMUAAAACABunWlNfy44XQkAAAAHAAAALAAAAAAA
AAAAAAAAtIHKeQAAcHl0b3JjaF9pZ25pdGUtMC4xLjEuZGlzdC1pbmZvL3RvcF9sZXZlbC50eHRQ
SwECFAMUAAAACAB5m2lNkwbXMgMAAAABAAAAJwAAAAAAAAAAAAAAtIEdegAAcHl0b3JjaF9pZ25p
dGUtMC4xLjEuZGlzdC1pbmZvL3ppcC1zYWZlUEsBAhQDFAAAAAgAbp1pTT1eHo6RBwAA8w0AACUA
AAAAAAAAAAAAALQBZXoAAHB5dG9yY2hfaWduaXRlLTAuMS4xLmRpc3QtaW5mby9SRUNPUkRQSwUG
AAAAACkAKQB8DAAAOYIAAAAA'''.replace('\n', '')


# In[ ]:


len(ignite_wheel)


# In[ ]:


get_ipython().system('echo $ignite_wheel | base64 -di - > pytorch_ignite-0.1.1-py2.py3-none-any.whl')


# In[ ]:


get_ipython().system('pip install pytorch_ignite-0.1.1-py2.py3-none-any.whl')


# In[ ]:


import os

import pandas as pd
import numpy as np

from sklearn import metrics
import random


# In[ ]:


from tqdm import tqdm_notebook, tqdm_pandas, tqdm
import matplotlib.pyplot as plt
get_ipython().run_line_magic('matplotlib', 'inline')

from itertools import chain


# In[ ]:


import logging

file_log = "log.log" # no limits
logger = logging.getLogger("NTB")

formatter = logging.Formatter(fmt="%(asctime)s - %(levelname)s - %(message)s",  datefmt="%F %T")

console_logging_handler = logging.StreamHandler()
console_logging_handler.setFormatter(formatter)

file_logging_handler = logging.FileHandler(file_log)
file_logging_handler.setFormatter(formatter)

logger.addHandler(file_logging_handler) 
logger.addHandler(console_logging_handler)
logger.setLevel(logging.DEBUG)


# In[ ]:


import torch

from torchtext import data, vocab
import spacy


# In[ ]:


kaggle = True
cuda = True

if cuda:
    torch.cuda.set_device(0 if kaggle else 2)


# In[ ]:


nlp = spacy.load('en')

nlp.remove_pipe('parser') # dont need PoS
nlp.remove_pipe('ner') # dont need NERs


# In[ ]:


def process_text(df):
    
    preprocessed = tqdm_notebook(nlp.pipe(
        tqdm_notebook(df.question_text), 
        batch_size=850 if kaggle else 1500, # batching processing is MUCH faster
        n_threads=4 if kaggle else 8
    ))
    
    df['processed'] = list(map(lambda x: ' '.join([_.lemma_ for _ in x]), preprocessed))


# In[ ]:


from random import random as get_rnd_flt

def make_iterators_from_sets(dataset):
    return data.BucketIterator(
        dataset=dataset, 
        shuffle=True, 
        repeat=True,
        batch_size=128,
        sort=False, # cant sort here due to real shuffling, need sophisticated preparation for using that feature
                    # will add this logic if comunity need that
        sort_key=lambda x: len(x.processed) + get_rnd_flt(), #random is for shuffling in equal-lenght batches, dont need now actually
        device='cuda' if cuda else None
)


# In[ ]:


def generate_vector(dim, phases=[1,5,123,216]):
    vec = torch.rand(1, dim)
    for i in range(dim):
        appfactor = 0
        for phase in phases:
            appfactor += np.cos(i * phase)
        appfactor = appfactor / len(phases)
        vec[0, i] = vec[0, i] + appfactor
    return vec


# In[ ]:


input_train_dir = '../input/train.csv' if kaggle else '/stor/comps/quora18/train.csv.zip'
input_predict_dir = '../input/test.csv' if kaggle else '/stor/comps/quora18/test.csv.zip'
input_embeddings_dir = '../input/embeddings/glove.840B.300d/glove.840B.300d.txt' if kaggle else '/stor/comps/quora18/glove.840B.300d/glove.840B.300d.txt'


# In[ ]:


if kaggle or not os.path.exists('temp_train.processed.csv'):
    datas = pd.read_csv(input_train_dir)
    process_text(datas)
    if not kaggle:
        datas.to_csv('temp_train.processed.csv', index=None)
else:
    datas = pd.read_csv('temp_train.processed.csv')


# In[ ]:


datas.shape


# In[ ]:


to_predict = pd.read_csv(input_predict_dir)

process_text(to_predict)


# In[ ]:


precessed_field = ('processed', data.Field( # "processed" is exapmle field name
    include_lengths=True, # may need seq lenght sometimes
    sequential=True, # tell fields preprocessors its texts aka token sequence
    init_token='<s>', # add special token at sequence start
    eos_token='</s>', # final special token
    batch_first=True, # I like batch dimension comes first 
))

label_field = ('target', data.LabelField()) # tell torchtext dataloader what to predict, named "target"


# In[ ]:


def df2examples(df, fields):
    return [
        data.Example.fromdict(row.to_dict(), fields) for _, row in tqdm_notebook(df.iterrows())
    ]


# In[ ]:


data_examples = df2examples(datas, {'processed':precessed_field, 'target':label_field})


# In[ ]:


text_dataset = data.Dataset(data_examples, dict([precessed_field, label_field]))


# In[ ]:


random.seed(42)

random_state = random.getstate() # TorchText need that state to be reproducible, I am not sure its enought

def make_split_on_ds(ds):
    return ds.split(
        split_ratio=[0.8, 0.1, 0.1], # train, cv, test
        stratified=True, 
        strata_field='target',
        random_state=random_state
    )


# In[ ]:


train_ds, val_ds, test_ds = make_split_on_ds(text_dataset)


# In[ ]:


all_examples_to_predict = df2examples(to_predict, {'processed': precessed_field})

to_predict_dataset = data.Dataset(all_examples_to_predict, dict([precessed_field]))

to_predict_iterator = data.BucketIterator(
    repeat=0, 
    sort=False, 
    shuffle=False, 
    train=False,
    batch_size=64,
    dataset=to_predict_dataset, 
    device='cuda' if cuda else None,
)


# In[ ]:


if kaggle:
    get_ipython().system('mkdir cache_vectors')

glove_vecs = vocab.Vectors(name=input_embeddings_dir, cache='cache_vectors/')


# In[ ]:


precessed_field[1].build_vocab(
    train_ds, 
    vectors=glove_vecs, 
    min_freq=3, 
    max_size=100000)

label_field[1].build_vocab(train_ds)


# In[ ]:


train_ds, val_ds, test_ds = [make_iterators_from_sets(_) for _ in [train_ds, val_ds, test_ds]]


# In[ ]:


lstm_hidden_size = 96
filters_size = 50
vecs_dim = 300
lstm_in_size = 300

log_interval = 50
epoch_interval = 250


# In[ ]:


early_stopping_patience = 5


# In[ ]:


def apply_nn_to_batcher(nn, batcher, loss_func=None, targets_enable=True):
    targets = []
    answers = []
    losses = []
    lengths = []

    nn.eval()  # Swith dropout off
    with torch.no_grad():
        for i, batch in enumerate(tqdm_notebook(batcher)):
            r = nn(batch.processed[0])  # batch.processed is tuple (data: [examples x seqLen x embDim], seqLength: [examples])
            if targets_enable:
                ttarget = batch.target.type(torch.float32).view(-1, 1)
                
                loss = loss_func(r, ttarget)
                
                targets.append(ttarget.cpu().numpy()) # save for further analasys
                losses.append(loss.item()) # save for further analasys
                
            lengths.append(batch.processed[1].cpu().numpy()) # save for further analasys
            answers.append(r.detach().cpu().numpy()) # preds
                            # detaches a tensor from computation graph
                                     # moves tensor to CPU from GPU
                                           # make numpy matrix from pytorch tensor
    
    
    #aggregate data from batches
    if targets_enable:
        targets = np.vstack(targets)
        
    answers = np.vstack(answers)
    lengths = np.vstack([_.reshape(-1, 1) for _ in lengths])
    
    if not targets_enable:
        return answers, lengths
    
    return targets, answers, lengths, losses


# In[ ]:


from torch import nn

# implementation from https://github.com/c0nn3r/pytorch_highway_networks

class Highway(nn.Module):
    def __init__(self, size, num_layers, f, drop_inner=None, drop_input=None):

        super(Highway, self).__init__()

        self.num_layers = num_layers

        self.nonlinear = nn.ModuleList([nn.Linear(size, size) for _ in range(num_layers)])

        self.linear = nn.ModuleList([nn.Linear(size, size) for _ in range(num_layers)])

        self.gate = nn.ModuleList([nn.Linear(size, size) for _ in range(num_layers)])

        if drop_inner is not None:
            self.drop_inner = nn.Dropout(drop_inner, inplace=True)

        if drop_input is not None:
            self.drop_input = nn.Dropout(drop_input, inplace=True)

        self.f = f

    def forward(self, x):
        """
            :param x: tensor with shape of [batch_size, size]
            :return: tensor with shape of [batch_size, size]
            applies (x)  (f(G(x))) + (1 - (x))  (Q(x)) transformation | G and Q is affine transformation,
            f is non-linear transformation, (x) is affine transformation with sigmoid non-linearition
            and  is element-wise multiplication
            """
        if hasattr(self, 'drop_input'):
            x = self.drop_input(x)

        for layer in range(self.num_layers):
            if hasattr(self, 'drop_inner'):
                x = self.drop_inner(x)

            gate = torch.sigmoid(self.gate[layer](x))

            nonlinear = self.f(self.nonlinear[layer](x))
            linear = self.linear[layer](x)

            x = gate * nonlinear + (1 - gate) * linear

        # return self.out_scaler(x)
        return x


# In[ ]:


class Classifier(torch.nn.Module):
    def __init__(self):
        super(Classifier, self).__init__()
        
#         self.prelstm = torch.nn.Sequential(
#             torch.nn.Linear(int(vecs_dim), int(vecs_dim/2)),
#             torch.nn.Tanh(),
#             torch.nn.Dropout(0.3), 
#             torch.nn.Linear(int(vecs_dim/2), lstm_in_size),
#             torch.nn.Dropout(0.2), 
#             torch.nn.Tanh(),
#         )
        
        self.lstm = torch.nn.LSTM(lstm_in_size, lstm_hidden_size, 2, batch_first=True, bidirectional=True,)
        
        self.blstm_dropout = torch.nn.Dropout(0.1)
        
        self.convs = torch.nn.ModuleList()
        for conv_len in range(2, 6):
            self.convs.append(torch.nn.Conv1d(lstm_hidden_size*2, filters_size, conv_len, groups=1))
        
        self.lstm2 = torch.nn.LSTM(lstm_hidden_size*2, lstm_hidden_size, batch_first=True)
        
        self.fcnn_size = (lstm_hidden_size*3+2*len(self.convs)*filters_size)
        
        self.simple_nn = torch.nn.Sequential(
#             torch.nn.BatchNorm1d(fcnn_size),
            torch.nn.Dropout(0.5),
            torch.nn.PReLU(),
            torch.nn.Linear(self.fcnn_size, int(lstm_hidden_size)),
            torch.nn.Dropout(0.1),
            Highway(int(lstm_hidden_size), 4, torch.nn.PReLU(), drop_inner=0.2),
            torch.nn.PReLU(),
            torch.nn.Linear(int(lstm_hidden_size), 1),
            torch.nn.Sigmoid()
        )
    
    def forward(self, batch):
        
        r = glove_embs(batch)
        r = self.lstm(r)[0]
        
        # real magic here, restore intuitive order of bilstm output
        # look for explanations here 
        # https://towardsdatascience.com/understanding-bidirectional-rnn-in-pytorch-5bd25a5dd66
        r = r.view(r.shape[0], r.shape[1], 2, lstm_hidden_size)        
        r = torch.cat(
            [
                r[:, : , 0 , :].view(r.shape[0], r.shape[1], 1, lstm_hidden_size),
                r[:, : , 1 , :].flip(dims=(1,)).view(r.shape[0], r.shape[1], 1, lstm_hidden_size)
            ]
            ,dim=2
        )
        
        r = self.blstm_dropout(r.view(r.shape[0], r.shape[1], lstm_hidden_size*2))        
        from_lstm = self.lstm2(r)[0]
        
        to_conv = r.transpose(1, 2)        
        convs = []
        for convlayer in self.convs:
            conv_r = convlayer(to_conv)
            convs.append(conv_r.max(2)[0]) # extract filters max activations
            convs.append(conv_r.min(2)[0]) # extract filters min activations
        
        convs = torch.cat(convs, dim=1)
        
        r = torch.cat(
            [
                from_lstm[:, -1, :].view(from_lstm.shape[0], lstm_hidden_size), # last state of lstm
                from_lstm.max(dim=1)[0].view(from_lstm.shape[0], lstm_hidden_size), # max activations of state
                from_lstm.min(dim=1)[0].view(from_lstm.shape[0], lstm_hidden_size), # min activations of state
                convs # previously extracted activations
            ], dim=1)
        
        r = self.simple_nn(r) # final decision
        return r


# In[ ]:


train_ds.repeat = True # infinite iterations
val_ds.repeat = False # one time iteration
test_ds.repeat = False # one time iteration


# In[ ]:


from ignite.engine import Engine, Events, create_supervised_evaluator
from ignite.metrics import Loss
from ignite.handlers import EarlyStopping, ModelCheckpoint

from ignite.contrib.handlers import CosineAnnealingScheduler, ProgressBar


# In[ ]:


from string import punctuation


# In[ ]:


random.seed(123)
torch.manual_seed(123)
if cuda:
    torch.cuda.manual_seed(123)


# In[ ]:


glove_embs = torch.nn.Embedding(
    precessed_field[1].vocab.vectors.shape[0], 
    precessed_field[1].vocab.vectors.shape[1]
)

glove_embs.weight.data = precessed_field[1].vocab.vectors.clone()

# fill special tokens vectors if nessesary
for specmark in ['<s>', '</s>', '<pad>', '-PRON-', ] + list(punctuation): #'<unk>'
    if specmark in precessed_field[1].vocab.stoi:
        continue
    glove_embs.weight.data[precessed_field[1].vocab.stoi[specmark]] = generate_vector(
        glove_embs.weight.shape[1],
        phases=[hash(specmark + _) % 256 for _ in ['', '1', '2', '3']]
    )

if cuda:
    glove_embs = glove_embs.cuda()


# In[ ]:


glove_embs.weight.data.shape


# In[ ]:


(glove_embs.weight.data == 0).all(dim=1).sum()


# In[ ]:


# Create NN instance
classifier = Classifier()
if cuda:
    classifier = classifier.cuda()

# Setup optimizer
opt = torch.optim.Adam(classifier.parameters(), lr=0.001, betas=(0.5, 0.9), amsgrad=True)

# Define loss function
train_loss_func = torch.nn.BCELoss() 
val_loss_func = torch.nn.BCELoss()
if cuda:
    train_loss_func = train_loss_func.cuda()
    val_loss_func = val_loss_func.cuda()

# define train iteration func for Ignite
def do_train_iter(engine, batch):
    
    classifier.train()
    
    r = classifier(batch.processed[0])
    typed_batch = batch.target.type(torch.float32).view(-1, 1)
    loss = train_loss_func(r, typed_batch)
    loss.backward()
    opt.step()
    opt.zero_grad()

    return loss.item()

# create Ignite Engine from iteration function
trainer = Engine(do_train_iter)

# attach to Ignite Engine artificial Event every epoch_interval times (iteration is infinite, remember?)
@trainer.on(Events.ITERATION_COMPLETED)
def make_epoch_end_announce(engine):
    if (trainer.state.iteration % epoch_interval == 0) and (engine.state.epoch > 0):
        logger.debug('Rising EPOCH_COMPLETED...')
        engine.fire_event(Events.EPOCH_COMPLETED)
        engine.state.epoch = engine.state.epoch + 1

# make evaluation iteration sometimes
@trainer.on(Events.EPOCH_COMPLETED)
def make_val_scores(engine):
    logger.debug('running evaluation')
    val_targets, val_answers, val_lengths, val_losses = apply_nn_to_batcher(
        classifier, 
        val_ds, 
        val_loss_func, 
        targets_enable=True
    )
    engine.state.valmetrics = {'all_ce': val_losses, 'bce':np.mean(val_losses)}
    logger.info("Validation Results - Epoch: %d BCE: %4.4f",
              engine.state.epoch, 
              engine.state.valmetrics['bce'],
    )

# add handler log losses history
train_bce_history = []
val_bce_history = []
train_lr_history = []

@trainer.on(Events.ITERATION_COMPLETED)
def track_train_loss(engine):
    train_bce_history.append((trainer.state.iteration, engine.state.output))
    train_lr_history.append((trainer.state.iteration, opt.param_groups[0]['lr']))

# log sometimes   
@trainer.on(Events.ITERATION_COMPLETED)
def log_training_loss(engine):
    iter = engine.state.iteration
    if iter % log_interval == 0:
        logger.debug('TRAIN BCE: %d\t%5.5f', iter, engine.state.output)
        logger.debug('  \tCURRENT LR: %d    \t%5.5f', iter, opt.param_groups[0]['lr'])
    
@trainer.on(Events.EPOCH_COMPLETED)
def track_val_loss(engine):
    val_bce_history.append((trainer.state.iteration, engine.state.valmetrics['bce']))


# Early stopping, use validation scores for decision
es_engine = EarlyStopping(early_stopping_patience, lambda x: -x.state.valmetrics['bce'], trainer)
trainer.add_event_handler(Events.EPOCH_COMPLETED, es_engine)


# cleanup
if not kaggle:
    get_ipython().system('rm -rf models_checkpoints/')

# checkpoint logic, saves best models, could save embeddings too, but its frozen for now
checkpointer = ModelCheckpoint(
    'models_checkpoints', 
    'glove_lstm', 
    n_saved=4, 
    score_function=lambda x: -x.state.valmetrics['bce'],
    save_as_state_dict=True
)
trainer.add_event_handler(Events.EPOCH_COMPLETED, checkpointer, {'mymodel': classifier})


# In[ ]:


trainer.run(tqdm_notebook(train_ds))


# In[ ]:


plt.plot(*zip(*train_bce_history[log_interval:]))
plt.plot(*zip(*val_bce_history[1:]))
plt.plot(*zip(*train_lr_history[log_interval:]))


# In[ ]:


checkpointer._saved


# In[ ]:


best_model = Classifier()

best_model.load_state_dict(torch.load(checkpointer._saved[-1][-1][0]))

if cuda:
    best_model = best_model.cuda()


# In[ ]:


val_targets, val_answers, val_lengths, val_losses = apply_nn_to_batcher(best_model, val_ds, val_loss_func)


# In[ ]:


import numpy as np
from sklearn import metrics

fpr, tpr, thresholds = metrics.roc_curve(val_targets, val_answers, pos_label=1)

roc_auc = metrics.auc(fpr, tpr)

# method I: plt
plt.title('Receiver Operating Characteristic')
plt.plot(fpr, tpr, 'b', label = 'AUC = %0.4f' % roc_auc)
plt.legend(loc = 'lower right')
plt.plot([0, 1], [0, 1],'r--')
plt.xlim([0, 1])
plt.ylim([0, 1])
plt.ylabel('True Positive Rate')
plt.xlabel('False Positive Rate')
plt.show()


# In[ ]:


f1s = []
points_to_check = thresholds[::15]
for _ in tqdm_notebook(points_to_check):
    f1s.append(metrics.f1_score(val_targets, val_answers > _))

best_threshold = points_to_check[np.argmax(f1s)]

plt.plot(points_to_check, f1s)
plt.plot(best_threshold, np.max(f1s), marker='x', markersize=20)


# In[ ]:


print(np.argmax(f1s), np.max(f1s), best_threshold, np.mean(val_targets), np.mean(val_answers > best_threshold))


# In[ ]:


loss_func = torch.nn.BCELoss()

if cuda:
    loss_func = loss_func.cuda()

test_targets, test_answers, test_lengths, test_losses = apply_nn_to_batcher(best_model, test_ds, loss_func)


# In[ ]:


print(metrics.f1_score(test_targets, test_answers > best_threshold))


# In[ ]:


np.mean(test_targets), np.mean(test_answers > best_threshold), np.mean(val_losses), np.mean(test_losses)


# In[ ]:





# In[ ]:


topred_answers, topred_lengths =     apply_nn_to_batcher(
    best_model, 
    to_predict_iterator, 
    loss_func=None, 
    targets_enable=False
)


# In[ ]:


to_predict['prediction'] = list(map(lambda x: int(x > best_threshold), topred_answers))


# In[ ]:


to_predict.prediction.mean()


# In[ ]:


to_predict.loc[to_predict.prediction == 1]


# In[ ]:


to_predict[['qid', 'prediction']].to_csv('submission.csv', index=None, header=True)


# In[ ]:




